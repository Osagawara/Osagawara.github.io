{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Dynamic Programing about String","text":"对于两个字符串之间的关系，有很多题目可以用动态规划的思想解答。关键是要找到两个字符串之间的状态转移方程。此处可以使用一个二维矩阵，找出两个字符串的前缀之间的关系，从而推出两个字符串之间的关系。 下面以LeetCode上面Interleaving String为例。 Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. 例如s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;，结果为True，而s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;，结果为False。 我们采用bool型二维数组interleave，interleave[i][j]代表s1的前i个字符与s2的前j个字符进行插入操作，能否得到s3的前i+j个字符。我们考虑以下几个情况： 如果interleave[i-1][j]和interleave[i][j-1]都为False，说明无论是s1的第i个字符还是s2的第j个字符都无法作为s3的末尾字符，此时interleave[i][j]必然为False。 除此之外，如果interleave[i-1][j] == True，说明s1[:i-1]能插入s2[:j]中得到s3[:i-1+j]。如果s1第i个字符等于s3的第i+j个字符，则interleave[i][j] = True。 除此之外，则interleave[i][j-1]必然True，说明s1[:i]能插入s2[:j-1]中得到s3[:i-1+j]。如果s2第j个字符等于s3的第i+j个字符，则interleave[i][j] = True。 我们可以得到状态转移方程如下 $$interleave[i][j] =\\begin{cases} False \\quad &amp; interleave[i-1][j] == False \\wedge \\\\ \\quad &amp; interleave[i][j-1] == False \\\\ s2[j-1] == s3[i+j-1] \\quad &amp; interleave[i][j-1] == True \\\\ s1[i-1] == s3[i+j-1] \\quad &amp; otherwise\\end{cases}$$ 对于边界条件，例如interleave[i][0]即代表着s1[:i]是否为s3[:i],则interleave[i][0] = interleave[i-1][0] and s1[i-1] == s3[i-1],同理interleave[0][i] = interleave[0][i-1] and s2[i-1] == s3[i-1]。最终interleave[len(s1)][len(s2)]即为所求。 原题例一的状态转移矩阵如下所示。","link":"/2019/09/01/Dynamic-Programing-about-String/"},{"title":"Largest Number","text":"题目给定一个非负整数的列表，将它们排序之后首尾相连得到一个整数，返回可得的最大整数 Example 1:Input: [10,2]Output: “210” Example 2:Input: [3,30,34,5,9]Output: “9534330” 解答先将整数列表转化为字符串列表，再进行排序。 一般情况，对于两个整数字符串a和b，如果将a排在前面会使结果更大，则a的字典序一定比b大，可以直接使用&gt;和&lt;来进行比较。 特殊情况，a是b的前缀，则b的字典序一定比a大，但此时b不总是排在a的前面。对于'998'和'99899'，有'99899' &gt; '998'。但是对于'338'和'33833'，我们必须确保'338' &gt; '33833'，这与python3内置比较相反。因此我们需要自定义一个用于排序的比较函数。 不妨设a是b的前缀，由于两者前面相同，则需要对a和b的除去前缀的部分进行比较，也即比较a和b[len(a):]。如果b[len(a):] &gt; a，则b &gt; a；如果b[len(a):] &lt; a，则b &lt; a。此外，有一种特殊情况，最后a或b可能为空串，说明a和b都是由相同的子串（不同数量）拼接而成，这时返回相等。最终自定义的比较函数如下。 12345678910111213141516171819def cmp_str(a, b): if a == &apos;&apos; or b == &apos;&apos;: return 0 la = len(a) lb = len(b) if la &lt;= lb and a == b[:la]: return cmp_str(a, b[la:]) if la &gt; lb and a[:lb] == b: return cmp_str(a[lb:], b) if a &gt; b: return 1 elif a == b: return 0 else: return -1 对于排序，functools.cmp_to_key可以将比较函数转化为key参数，输入到sort()中。","link":"/2019/07/15/Largest-Number/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/14/hello-world/"},{"title":"LeetCode Database","text":"这次的两个题目涉及比较关系，mysql中求取某一属性的最大值，可以使用聚合函数max()。如果求第二大值，可以求取小于最大值的最大值。如果是第三大、第四大甚至第五大值之时，就不能像这样循环地定义。下面这道题给出了一个不同的思路。 Department Top Three Salaries题目给定如下一个关系Employee，求每个部门前三高的薪水和雇员，相等的薪水排在同一位。 123456789101112+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 85000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 || 5 | Janet | 69000 | 1 || 6 | Randy | 85000 | 1 || 7 | Will | 70000 | 1 |+----+-------+--------+--------------+ 解答第三高的薪水，意味着排在其前面的不同的薪水只有两个。给定两个Employee关系e1和e2，对于e1中的每个条目，我们只需统计e2中与其相同部门且薪水比它大的不同薪水的数目，该数目为2则e1的对应条目为所求。同时第二高和第一高的薪水，该数目分别为1和0。 mysql语句如下 12345678910select name, salary, departmentIDfrom Employee as e1where 2 &gt;= ( select count( distinct e2.salary) from Employee as e2 where e2.departmentID = e1.departmentID and e2.salary &gt; e1.salary); 另一个题目是关于多个连续条目的问题。 Human Traffic of Stadium题目给定如下一个关系Stadium，求出那些连续三天及以上人数不低于100的条目。 12345678910111213 +------+------------+-----------+| id | visit_date | people |+------+------------+-----------+| 1 | 2017-01-01 | 10 || 2 | 2017-01-02 | 109 || 3 | 2017-01-03 | 150 || 4 | 2017-01-04 | 99 || 5 | 2017-01-05 | 145 || 6 | 2017-01-06 | 1455 || 7 | 2017-01-07 | 199 || 8 | 2017-01-08 | 188 |+------+------------+-----------+ 解答由表中可知，日期和id都是连续的，我们只需找出id连续3个及以上的即可。连续三天及以上意味着条目满足下面三个条件之一： 该条目和下个相邻条目和下下个相邻条目都是不少于100人 该条目和上个相邻条目和下个相邻条目都是不少于100人 该条目和上个相邻条目和上上个相邻条目都是不少于100人 这些可以用id之间的差距来表示。我们可以求出三个Stadium关系t1、 t2和t3的笛卡尔积，求出其中三个人数都不少于100，且id满足上述条件的条目，取出其中t1的属性，排序即可。 123456789101112 select distinct t1.* from stadium as t1, stadium as t2, stadium as t3where t1.people &gt;= 100 and t2.people &gt;= 100 and t3.people &gt;= 100and ( (t1.id = t2.id - 1 and t1.id = t3.id - 2) or (t1.id = t2.id + 1 and t1.id = t3.id + 2) or (t1.id = t2.id - 1 and t1.id = t3.id + 1))order by t1.id;","link":"/2019/07/22/LeetCode-Database/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"日本","slug":"日本","link":"/tags/日本/"},{"name":"首相","slug":"首相","link":"/tags/首相/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Database","slug":"LeetCode/Database","link":"/categories/LeetCode/Database/"},{"name":"Dynamic Programming","slug":"LeetCode/Dynamic-Programming","link":"/categories/LeetCode/Dynamic-Programming/"},{"name":"日本","slug":"日本","link":"/categories/日本/"},{"name":"Sort","slug":"LeetCode/Sort","link":"/categories/LeetCode/Sort/"},{"name":"首相","slug":"日本/首相","link":"/categories/日本/首相/"}]}